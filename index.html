<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shooter Simulator (With Velocity Compensation)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 100;
            border: 1px solid #444;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: #ddd;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 1px solid #444;
            pointer-events: none;
        }
        .value {
            color: #ffaa00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Shooter Simulator (No Velocity Compensation)</h2>
        <p>Distance to goal: <span id="dist-display" class="value">0.0</span> in</p>
        <p>Hood angle: <span id="angle-display" class="value">0.0°</span></p>
        <p>Hood value: <span id="hood-display" class="value">0.0</span></p>
        <p>Flywheel speed: <span id="speed-display" class="value">0.0</span> in/s</p>
        <p>RPM: <span id="rpm-display" class="value">0.0</span></p>
        <p>Time of flight: <span id="time-display" class="value">0.00</span> s</p>
        <p>Robot velocity: <span id="vel-display" class="value">0.0</span> in/s</p>
    </div>
    <div id="controls">
        <b>Controls:</b> WASD = move, Arrow ←/→ = rotate robot, Space = shoot<br>
        Turret auto‑aims at the goal (box target).
    </div>

    <!-- Import Three.js and OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants from the original code ---
        const G = 32.174 * 12;          // in/s²
        const SCORE_HEIGHT = 46.0;       // inches (goal height above ground)
        const SCORE_ANGLE = -20 * Math.PI/180; // radians
        const PASS_THROUGH_RADIUS = 5.0; // inches
        // Hood limits (assumed, adjust if needed)
        const HOOD_MAX_ANGLE = 70 * Math.PI/180; // 70°
        const HOOD_MIN_ANGLE = 10 * Math.PI/180; // 10°

        // Goal position (fixed) - using Y as up
        const GOAL_POS = new THREE.Vector3(200, SCORE_HEIGHT, 0); // x, y, z (y up)

        // --- Setup scene, camera, renderer ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(250, 200, 250);
        camera.lookAt(100, 50, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(100, 50, 50);
        controls.enableDamping = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(100, 200, 200);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 300;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 400;
        scene.add(dirLight);

        const fillLight = new THREE.PointLight(0x446688, 0.5);
        fillLight.position.set(0, 100, 100);
        scene.add(fillLight);

        // --- Ground grid and axes ---
        const gridHelper = new THREE.GridHelper(400, 20, 0x88aaff, 0x335588);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);

        // Floor plane (visual ground)
        const planeGeo = new THREE.PlaneGeometry(800, 800);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1a2130 });
        const floor = new THREE.Mesh(planeGeo, planeMat);
        floor.rotation.x = -Math.PI/2; // make plane horizontal with normal +Y
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- Goal (a box target) ---
        const goalMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
        const goalGeo = new THREE.BoxGeometry(16, 20, 16); // width, height, depth
        const goalMesh = new THREE.Mesh(goalGeo, goalMat);
        goalMesh.castShadow = true;
        goalMesh.receiveShadow = true;
        goalMesh.position.copy(GOAL_POS);
        scene.add(goalMesh);

        // --- Robot ---
        const robotGroup = new THREE.Group();
        robotGroup.position.set(0, 0, 0); // start at origin (y is up)

        // Chassis (simple box) - width, height, depth (height should be small)
        const chassisGeo = new THREE.BoxGeometry(30, 10, 30);
        const chassisMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
        const chassis = new THREE.Mesh(chassisGeo, chassisMat);
        chassis.position.y = 5; // half height (y up)
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        robotGroup.add(chassis);

        // Turret base (rotates in yaw)
        const turretBaseGeo = new THREE.CylinderGeometry(8, 8, 5, 16);
        const turretBaseMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
        const turretBase = new THREE.Mesh(turretBaseGeo, turretBaseMat);
        turretBase.position.y = 10 + 2.5; // on top of chassis
        turretBase.castShadow = true;
        turretBase.receiveShadow = true;
        robotGroup.add(turretBase);

        // Turret group (yaw)
        const turretGroup = new THREE.Group();
        turretGroup.position.y = 10 + 5; // at top of base
        robotGroup.add(turretGroup);

        // Pitch group (holds the barrel)
        const pitchGroup = new THREE.Group();
        turretGroup.add(pitchGroup);

        // Barrel (cylinder initially pointing along +X for forward)
        const barrelLength = 20;
        const barrelGeo = new THREE.CylinderGeometry(2, 2, barrelLength, 8);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        // rotate cylinder (default along Y) to point along +X
        barrel.rotation.z = Math.PI/2;
        console.log(barrel.rotation);
        // Position so base is at origin and tip at +X
        barrel.position.x = barrelLength/2;
        barrel.castShadow = true;
        barrel.receiveShadow = true;
        pitchGroup.add(barrel);

        // Ball at the end of the barrel (visual only)
        const ballRadius = 2.45; // 4.9" diameter
        const ballGeo = new THREE.SphereGeometry(ballRadius, 16, 16);
        const ballMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
        const ballVisual = new THREE.Mesh(ballGeo, ballMat);
        ballVisual.position.x = barrelLength; // at tip (along +X)
        ballVisual.castShadow = true;
        ballVisual.receiveShadow = true;
        pitchGroup.add(ballVisual);

        scene.add(robotGroup);

        // --- Projectile manager ---
        const projectiles = [];
        const maxProjectiles = 20;

        function spawnProjectile(position, velocity) {
            if (projectiles.length >= maxProjectiles) {
                // remove oldest
                const old = projectiles.shift();
                scene.remove(old.mesh);
            }
            const geo = new THREE.SphereGeometry(ballRadius * 0.8, 12, 12);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff5500 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            mesh.castShadow = true;
            scene.add(mesh);
            projectiles.push({ mesh, velocity, age: 0 });
        }

        // --- Trajectory preview line ---
        const trajectoryPoints = [];
        const trajectoryLineGeo = new THREE.BufferGeometry();
        const trajectoryLineMat = new THREE.LineBasicMaterial({ color: 0xffaa00 });
        const trajectoryLine = new THREE.Line(trajectoryLineGeo, trajectoryLineMat);
        scene.add(trajectoryLine);

        // --- Input handling ---
        const keyState = {
            w: false, a: false, s: false, d: false,
            arrowLeft: false, arrowRight: false
        };
        
        // Robot movement state (acceleration and velocity)
        let accelX = 0;  // acceleration in world X
        let accelZ = 0;  // acceleration in world Z
        let velocityX = 0;  // velocity in world X
        let velocityZ = 0;  // velocity in world Z
        const maxVelocity = 80;  // in/s
        const accelerationRate = 150;  // in/s² (how fast keys add acceleration)
        const friction = 0.92;  // friction coefficient (0-1, closer to 1 = less friction)
        
        window.addEventListener('keydown', (e) => {
            const key = e.key;
            if (key === 'w' || key === 'W') { keyState.w = true; e.preventDefault(); }
            if (key === 'a' || key === 'A') { keyState.a = true; e.preventDefault(); }
            if (key === 's' || key === 'S') { keyState.s = true; e.preventDefault(); }
            if (key === 'd' || key === 'D') { keyState.d = true; e.preventDefault(); }
            if (key === 'ArrowLeft') { keyState.arrowLeft = true; e.preventDefault(); }
            if (key === 'ArrowRight') { keyState.arrowRight = true; e.preventDefault(); }
            if (e.code === 'Space') {
                e.preventDefault();
                // Shoot!
                const muzzlePos = getMuzzleWorldPosition();
                const velocityDir = getMuzzleDirection();
                const speed = currentFlywheelSpeed; // from last calculation
                if (speed > 0 && currentHoodAngleValid) {
                    const vel = velocityDir.multiplyScalar(speed).add(robotVel); // add robot velocity (world)
                    spawnProjectile(muzzlePos, vel);
                }
            }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key;
            if (key === 'w' || key === 'W') { keyState.w = false; e.preventDefault(); }
            if (key === 'a' || key === 'A') { keyState.a = false; e.preventDefault(); }
            if (key === 's' || key === 'S') { keyState.s = false; e.preventDefault(); }
            if (key === 'd' || key === 'D') { keyState.d = false; e.preventDefault(); }
            if (key === 'ArrowLeft') { keyState.arrowLeft = false; e.preventDefault(); }
            if (key === 'ArrowRight') { keyState.arrowRight = false; e.preventDefault(); }
        });

        // Helper to get muzzle world position
        function getMuzzleWorldPosition() {
            const tipPos = new THREE.Vector3(barrelLength, 0, 0);
            return tipPos.clone().applyMatrix4(pitchGroup.matrixWorld);
        }

        function getMuzzleDirection() {
            // direction is +X in pitchGroup local, transformed to world
            const dir = new THREE.Vector3(1, 0, 0);
            return dir.transformDirection(pitchGroup.matrixWorld).normalize();
        }

        // --- Math functions ---
        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        // Conversion functions from ShooterConverter
        function getAngleFromHood(hood) {
            return hood * 43.42315 - 0.491943;
        }

        function getHoodFromAngle(angle) {
            return (angle + 0.491943) / 43.42315;
        }

        function getVelocityFromRPM(rpm) {
            return 0.0407204 * rpm + 63.81966;
        }

        function getRPMFromVelocity(velocity) {
            return (velocity - 63.81966) / 0.0407204;
        }

        // Compute hood angle and flywheel speed given horizontal distance x (after subtracting radius)
        // and vertical difference y.
        function computeShotParameters(x, y) {
            if (x <= 0) return { hoodAngle: null, speed: null };
            
            // Raw hood angle from formula: atan(2*y/x - tan(a))
            let rawAngle = Math.atan(2 * y / x - Math.tan(SCORE_ANGLE));
            let hoodAngle = clamp(rawAngle, HOOD_MIN_ANGLE, HOOD_MAX_ANGLE);
            
            // Compute speed
            const cosH = Math.cos(hoodAngle);
            const tanH = Math.tan(hoodAngle);
            const denominator = 2 * cosH * cosH * (x * tanH - y);
            if (denominator <= 0) return { hoodAngle: null, speed: null };
            
            const speed = Math.sqrt(G * x * x / denominator);
            return { hoodAngle, speed };
        }

        // Compute shot parameters with velocity compensation
        // Based on the proper physics from the Java shooter code
        function computeShotParametersWithVelocity(dx, dz, y, robotVelX, robotVelZ) {
            // dx, dz: vector from muzzle to goal (in world coordinates)
            // y: vertical distance to goal
            // robotVelX, robotVelZ: robot's velocity in world coordinates
            
            const horizDist = Math.sqrt(dx * dx + dz * dz);
            const x = horizDist - PASS_THROUGH_RADIUS;
            
            if (x <= 0) return { hoodAngle: null, speed: null, turretYawOffset: 0 };
            
            // Step 1: Calculate initial launch components
            let hoodAngle = clamp(
                Math.atan(2 * y / x - Math.tan(SCORE_ANGLE)),
                HOOD_MIN_ANGLE,
                HOOD_MAX_ANGLE
            );
            
            let flywheelSpeed = Math.sqrt(
                G * x * x /
                (2 * Math.pow(Math.cos(hoodAngle), 2) *
                (x * Math.tan(hoodAngle) - y))
            );
            
            // Step 2: Decompose robot velocity into parallel and perpendicular components
            // relative to the robot-to-goal vector
            const robotVelMag = Math.sqrt(robotVelX * robotVelX + robotVelZ * robotVelZ);
            
            if (robotVelMag < 0.01) {
                // No robot velocity, return initial parameters
                return { hoodAngle, speed: flywheelSpeed, turretYawOffset: 0 };
            }
            
            // Direction from muzzle to goal
            const shotDirX = dx / horizDist;
            const shotDirZ = dz / horizDist;
            
            // Robot velocity direction
            const robotVelDirX = robotVelX / robotVelMag;
            const robotVelDirZ = robotVelZ / robotVelMag;
            
            // Angle between robot velocity and shot direction
            const coordinateTheta = Math.atan2(robotVelZ, robotVelX) - Math.atan2(dz, dx);
            
            // Parallel component (negative = moving away from goal)
            const parallelComponent = -Math.cos(coordinateTheta) * robotVelMag;
            
            // Perpendicular component
            const perpendicularComponent = Math.sin(coordinateTheta) * robotVelMag;
            
            // Step 3: Calculate velocity compensation
            const vz = flywheelSpeed * Math.sin(hoodAngle); // vertical component of launch velocity
            const time = x / (flywheelSpeed * Math.cos(hoodAngle)); // time of flight
            
            // Ideal velocity requirement to hit the adjusted target
            const ivr = x / time + parallelComponent;
            
            // New velocity requirement accounting for perpendicular motion
            const nvr = Math.sqrt(ivr * ivr + perpendicularComponent * perpendicularComponent);
            
            // New distance requirement
            const ndr = nvr * time;
            
            // Step 4: Recalculate launch components with compensated values
            hoodAngle = clamp(
                Math.atan(vz / nvr),
                HOOD_MIN_ANGLE,
                HOOD_MAX_ANGLE
            );
            
            flywheelSpeed = Math.sqrt(
                G * ndr * ndr /
                (2 * Math.pow(Math.cos(hoodAngle), 2) *
                (ndr * Math.tan(hoodAngle) - y))
            );
            
            // Step 5: Calculate turret yaw offset for perpendicular velocity compensation
            const turretYawOffset = Math.atan2(perpendicularComponent, ivr);
            
            return { hoodAngle, speed: flywheelSpeed, turretYawOffset };
        }

        // Current values (for display and shooting)
        let currentHoodAngle = 0;
        let currentFlywheelSpeed = 0;
        let currentTimeOfFlight = 0;
        let currentHoodAngleValid = false;

            // robot velocity tracking (world units / s)
            const prevRobotPos = robotGroup.position.clone();
            const robotVel = new THREE.Vector3(0,0,0);

        // --- Update loop ---
        const clock = new THREE.Clock();

        function update() {
            const dt = clock.getDelta();
            // Limit dt to avoid large jumps
            const safeDt = Math.min(dt, 0.05);

            // --- Robot movement (field-centric): inputs map to world axes X/Z ---
            // Input adds to acceleration
            accelX = 0;
            accelZ = 0;
            if (keyState.w) accelX += accelerationRate;
            if (keyState.s) accelX -= accelerationRate;
            if (keyState.a) accelZ -= accelerationRate;
            if (keyState.d) accelZ += accelerationRate;
            
            // Apply friction to velocity
            velocityX *= friction;
            velocityZ *= friction;
            
            // Update velocity based on acceleration
            velocityX += accelX * safeDt;
            velocityZ += accelZ * safeDt;
            
            // Clamp velocity to max
            const speedLength = Math.sqrt(velocityX * velocityX + velocityZ * velocityZ);
            if (speedLength > maxVelocity) {
                const scale = maxVelocity / speedLength;
                velocityX *= scale;
                velocityZ *= scale;
            }
            
            // Update position based on velocity
            robotGroup.position.x += velocityX * safeDt;
            robotGroup.position.z += velocityZ * safeDt;
            // Rotation still via arrow keys (rotates robot about Y)
            const rotateSpeed = 2; // rad/s
            if (keyState.arrowLeft) robotGroup.rotation.y += rotateSpeed * safeDt;
            if (keyState.arrowRight) robotGroup.rotation.y -= rotateSpeed * safeDt;

            // --- Auto-aim: point turret at goal ---
            // Get robot position
            const robotPos = robotGroup.position.clone();
            // ignore vertical (y) for yaw calculation; use X/Z plane
            const toGoal = new THREE.Vector3().subVectors(GOAL_POS, robotPos);
            toGoal.y = 0; // ignore height for yaw
            const targetYaw = Math.atan2(toGoal.z, toGoal.x);
            // Robot's heading
            const robotYaw = robotGroup.rotation.y;
            // Local turret yaw (relative to robot)
            let localYaw = targetYaw - robotYaw;
            // Normalize
            while (localYaw > Math.PI) localYaw -= 2*Math.PI;
            while (localYaw < -Math.PI) localYaw += 2*Math.PI;
            
            // Will be updated with velocity compensation offset below
            let turretYawWithCompensation = -localYaw;

            // --- Compute shot parameters based on current position ---
            const muzzlePos = getMuzzleWorldPosition();
            const dx = GOAL_POS.x - muzzlePos.x + 8;
            const dz = GOAL_POS.z - muzzlePos.z;
            const horizDist = Math.sqrt(dx*dx + dz*dz);
            const x = horizDist - PASS_THROUGH_RADIUS;
            const y = GOAL_POS.y - muzzlePos.y; // vertical difference (y up)

            let hoodAngle, speed;
            const params = computeShotParametersWithVelocity(dx, dz, y, velocityX, velocityZ);
            if (params.hoodAngle !== null && params.speed !== null) {
                hoodAngle = params.hoodAngle;
                speed = params.speed;
                currentHoodAngleValid = true;
                currentHoodAngle = hoodAngle;
                currentFlywheelSpeed = speed;

                // Compute time of flight (horizontal distance / horizontal speed)
                const vHoriz = speed * Math.cos(hoodAngle);
                currentTimeOfFlight = x / vHoriz;

                // Set turret pitch: barrel points along +X locally; pitch by rotating around local Z
                // hoodAngle is measured above horizontal, so rotate positive about Z
                pitchGroup.rotation.z = hoodAngle;
                
                // Apply turret yaw offset for velocity compensation
                turretYawWithCompensation = -localYaw + params.turretYawOffset;
            } else {
                currentHoodAngleValid = false;
                // fallback pitch
                pitchGroup.rotation.z = 0.3; // small default-up
            }
            
            // Apply the turret yaw (with or without velocity compensation)
            turretGroup.rotation.y = turretYawWithCompensation;

            // Update UI
            document.getElementById('dist-display').innerText = horizDist.toFixed(1);
            if (currentHoodAngleValid) {
                const angleDegrees = hoodAngle * 180/Math.PI;
                const hoodValue = getHoodFromAngle(angleDegrees);
                const rpm = getRPMFromVelocity(speed);
                
                document.getElementById('angle-display').innerText = angleDegrees.toFixed(1);
                document.getElementById('hood-display').innerText = hoodValue.toFixed(4);
                document.getElementById('speed-display').innerText = speed.toFixed(0);
                document.getElementById('rpm-display').innerText = rpm.toFixed(0);
                document.getElementById('time-display').innerText = currentTimeOfFlight.toFixed(2);
            } else {
                document.getElementById('angle-display').innerText = 'N/A';
                document.getElementById('hood-display').innerText = 'N/A';
                document.getElementById('speed-display').innerText = 'N/A';
                document.getElementById('rpm-display').innerText = 'N/A';
                document.getElementById('time-display').innerText = 'N/A';
            }

            // --- Robot velocity calculation (world units / s)
            robotVel.copy(robotGroup.position).sub(prevRobotPos).divideScalar(Math.max(safeDt, 1e-6));
            prevRobotPos.copy(robotGroup.position);
            document.getElementById('vel-display').innerText = robotVel.length().toFixed(1);

            // --- Draw predicted trajectory if valid ---
            if (currentHoodAngleValid) {
                const steps = 50;
                const points = [];
                const dtTraj = currentTimeOfFlight / steps;
                const v0 = speed;
                
                // Launch position
                const pos0 = muzzlePos.clone();
                
                // Get the actual barrel direction in world space
                const barrelDir = getMuzzleDirection();
                
                // Initial velocity in world space (barrel direction * speed + robot velocity)
                const initialVel = barrelDir.clone().multiplyScalar(v0).add(new THREE.Vector3(velocityX, 0, velocityZ));
                
                for (let i = 0; i <= steps; i++) {
                    const t = i * dtTraj;
                    const xPos = pos0.x + initialVel.x * t;
                    const zPos = pos0.z + initialVel.z * t;
                    const yPos = pos0.y + initialVel.y * t - 0.5 * G * t * t;
                    points.push(new THREE.Vector3(xPos, yPos, zPos));
                }
                trajectoryLine.geometry.dispose();
                trajectoryLine.geometry = new THREE.BufferGeometry().setFromPoints(points);
            } else {
                trajectoryLine.geometry.dispose();
                trajectoryLine.geometry = new THREE.BufferGeometry();
            }

            // --- Update projectiles ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                // Simple Euler integration (Y-up gravity)
                p.velocity.y -= G * safeDt;
                p.mesh.position.x += p.velocity.x * safeDt;
                p.mesh.position.y += p.velocity.y * safeDt;
                p.mesh.position.z += p.velocity.z * safeDt;
                p.age += safeDt;

                // Remove if below ground or too far
                if (p.mesh.position.y < -10 || p.age > 10) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        update();

        // --- Resize handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Add some floating markers for reference ---
        const markerMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const markerPositions = [
            [100, 0, 100], [100, 0, -100], [-100, 0, 100], [-100, 0, -100]
        ];
        markerPositions.forEach(pos => {
            const marker = new THREE.Mesh(new THREE.SphereGeometry(3, 8), markerMat);
            marker.position.set(pos[0], pos[1], pos[2]);
            scene.add(marker);
        });
    </script>
</body>
</html>